// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "src/Pool.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ReadOnlyReentrancy is Test {
    Pool public pool;
    MockToken public token;
    TargetDefiProtocol public targetDefiProtocol;
    uint public updatedMarginalPrice;

    function setUp() public {
        token = new MockToken();
        pool = new Pool(token);
        targetDefiProtocol = new TargetDefiProtocol(pool);

        // Set reserves
        vm.deal(address(pool), 1000); // ETH: 1000
        deal(address(token), address(pool), 50000); // ERC20 Token: 50000

        // Set contract balance
        vm.deal(address(this), 0);
        deal(address(token), address(this), 1e18);
    }

    function test_readOnlyReentrancy() public {
        uint initialMarginalPrice = pool.getETHPriceInToken();
        assertEq(initialMarginalPrice, 50);

        // SWAP
        token.approve(address(pool), 1000);
        pool.swapTokenForEth(1000);
        assertEq(address(this).balance, 19);

        // Compare the initial marginal price with the marginal price got from the targetDefiProtocol. It is the same, even after the swap.
        assertEq(initialMarginalPrice, updatedMarginalPrice);
        assertEq(pool.getETHPriceInToken(), 51);
    }

    // Receives ETH from swap and calls the targetDefiProtocol before the swapTokenForEth() transaction is done.
    receive() external payable {
        updatedMarginalPrice = targetDefiProtocol.getPoolMarginalPrice();
    }
}

contract MockToken is ERC20 {
    constructor() ERC20("MockToken", "MTK") {
        _mint(msg.sender, 1000000 * 18 ** decimals());
    }
}

contract TargetDefiProtocol {

    Pool public pool;

    constructor(Pool _pool){
        pool = _pool;
    }

    function getPoolMarginalPrice() public view returns (uint){
        return pool.getETHPriceInToken();
    }
}